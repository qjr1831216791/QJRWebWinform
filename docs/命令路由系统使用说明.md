# NativeHost 命令路由系统使用说明

## 架构概述

NativeHost 现在采用类似 WebAPI Controller 的命令路由架构，通过统一的入口 `executeCommand` 来调用各种功能，而不是为每个功能单独编写方法。

### 架构优势

1. **统一入口**：所有功能通过 `executeCommand` 调用
2. **易于扩展**：新增功能只需创建新的 Command 类
3. **易于管理**：所有命令集中管理，便于维护
4. **类型安全**：通过参数类定义参数结构
5. **支持同步和异步**：灵活的执行方式

## 架构设计

```
NativeHost (统一入口)
    ↓
CommandRegistry (命令注册表)
    ↓
ICommand (命令接口)
    ↓
具体 Command 类 (ShowMessageCommand, GetSystemInfoCommand 等)
```

## 前端调用方式

### 同步命令调用

```javascript
// 基本调用（无参数）
const result = JSON.parse(window.nativeHost.executeCommand('getSystemInfo'))
if (result.success) {
    console.log('系统信息:', result.data)
} else {
    console.error('错误:', result.error)
}

// 带参数调用
const params = JSON.stringify({ message: 'Hello', title: '测试' })
const result = JSON.parse(window.nativeHost.executeCommand('showMessage', params))
```

### 异步命令调用

```javascript
// 异步调用（带回调）
const params = JSON.stringify({ data: 'test data' })
window.nativeHost.executeCommandAsync('saveData', params, (success, message) => {
    if (success) {
        console.log('成功:', message)
    } else {
        console.error('失败:', message)
    }
})
```

### 返回结果格式

所有命令返回统一的 JSON 格式：

**成功时**：
```json
{
    "success": true,
    "data": { /* 命令返回的数据 */ }
}
```

**失败时**：
```json
{
    "success": false,
    "error": "错误信息"
}
```

## 后端开发新命令

### 步骤 1：创建命令类

在 `Commands` 目录下创建新的命令类，继承 `CommandBase`：

```csharp
using QJRWebWinform.WPF.Commands;

namespace QJRWebWinform.WPF.Commands
{
    /// <summary>
    /// 示例命令
    /// </summary>
    public class MyCustomCommand : CommandBase
    {
        public override string Name => "myCustomCommand";

        public MyCustomCommand(Window mainWindow) : base(mainWindow)
        {
        }

        public override object Execute(string parameters)
        {
            // 解析参数
            var param = DeserializeParameters<MyParams>(parameters);
            
            // 执行业务逻辑
            // ...
            
            // 返回结果
            return new { result = "success" };
        }

        // 如果需要异步执行，重写 ExecuteAsync
        public override void ExecuteAsync(string parameters, IJavascriptCallback callback)
        {
            // 异步逻辑
        }

        private class MyParams
        {
            public string Param1 { get; set; }
            public int Param2 { get; set; }
        }
    }
}
```

### 步骤 2：注册命令

在 `NativeHost.cs` 的 `RegisterCommands()` 方法中注册新命令：

```csharp
private void RegisterCommands()
{
    CommandRegistry.RegisterRange(new ICommand[]
    {
        // ... 现有命令
        new MyCustomCommand(_mainWindow)  // 添加新命令
    });
}
```

### 步骤 3：前端调用

```javascript
// 前端调用
const params = JSON.stringify({ param1: 'value1', param2: 123 })
const result = JSON.parse(window.nativeHost.executeCommand('myCustomCommand', params))
```

## 现有命令列表

| 命令名称 | 说明 | 参数 | 返回 |
|---------|------|------|------|
| `showMessage` | 显示消息框 | `{ message: string, title?: string }` | `{ success: true, data: {...} }` |
| `getSystemInfo` | 获取系统信息 | 无 | `{ success: true, data: { osVersion, dotNetVersion, ... } }` |
| `processData` | 处理数据 | `{ input: string }` | `{ success: true, data: { input, output } }` |
| `saveData` | 保存数据（异步） | `{ data: string }` | 通过回调返回 |
| `setWindowTitle` | 设置窗口标题 | `{ title: string }` | `{ success: true, data: { title } }` |
| `closeWindow` | 关闭窗口 | 无 | `{ success: true, data: {...} }` |

## 命令命名规范

1. **命令名称**：使用 camelCase（如 `showMessage`）
2. **类名称**：使用 PascalCase + Command 后缀（如 `ShowMessageCommand`）
3. **参数类**：使用 PascalCase + Params 后缀（如 `ShowMessageParams`）

## 最佳实践

### 1. 参数验证

```csharp
public override object Execute(string parameters)
{
    var param = DeserializeParameters<MyParams>(parameters);
    if (param == null || string.IsNullOrWhiteSpace(param.RequiredField))
    {
        throw new ArgumentException("必需参数不能为空");
    }
    // ...
}
```

### 2. UI 线程操作

```csharp
InvokeOnUIThread(() =>
{
    // UI 操作
    MainWindow.Title = "New Title";
});
```

### 3. 异步操作

```csharp
public override void ExecuteAsync(string parameters, IJavascriptCallback callback)
{
    System.Threading.Tasks.Task.Run(() =>
    {
        try
        {
            // 长时间运行的操作
            // ...
            callback.ExecuteAsync(true, "操作成功");
        }
        catch (Exception ex)
        {
            callback.ExecuteAsync(false, ex.Message);
        }
    });
}
```

### 4. 错误处理

所有命令都应该有适当的错误处理，异常会被自动捕获并返回错误信息。

## 调试命令

获取所有可用命令列表：

```javascript
const commands = JSON.parse(window.nativeHost.getAvailableCommands())
console.log('可用命令:', commands)
```

## 迁移指南

### 从旧方法迁移到新命令

**旧方式**：
```javascript
window.nativeHost.showMessage('Hello')
```

**新方式**：
```javascript
const params = JSON.stringify({ message: 'Hello' })
const result = JSON.parse(window.nativeHost.executeCommand('showMessage', params))
```

## 总结

- ✅ 统一入口：`executeCommand` 和 `executeCommandAsync`
- ✅ 易于扩展：创建新 Command 类即可
- ✅ 类型安全：通过参数类定义参数
- ✅ 统一格式：所有命令返回相同格式的 JSON
- ✅ 易于管理：所有命令集中注册和管理

